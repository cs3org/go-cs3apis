// Code generated by protoc-gen-go. DO NOT EDIT.
// source: cs3/storage/provider/v1beta1/resources.proto

package providerv1beta1

import (
	fmt "fmt"
	v1beta12 "github.com/cs3org/go-cs3apis/cs3/identity/group/v1beta1"
	v1beta11 "github.com/cs3org/go-cs3apis/cs3/identity/user/v1beta1"
	v1beta1 "github.com/cs3org/go-cs3apis/cs3/types/v1beta1"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// The available type of locks for a resource.
type LockType int32

const (
	LockType_LOCK_TYPE_INVALID LockType = 0
	// Shared (advisory) lock: the resource can be read,
	// written/overwritten or unlocked by everyone who has access.
	LockType_LOCK_TYPE_SHARED LockType = 1
	// Write lock: the resource can be read by everyone who has
	// access, but write, refreshlock and unlock operations
	// are restricted to the lock holder.
	LockType_LOCK_TYPE_WRITE LockType = 2
	// Exclusive lock: only the lock holder can operate on the
	// resource, anyone else is denied to access it.
	LockType_LOCK_TYPE_EXCL LockType = 3
)

var LockType_name = map[int32]string{
	0: "LOCK_TYPE_INVALID",
	1: "LOCK_TYPE_SHARED",
	2: "LOCK_TYPE_WRITE",
	3: "LOCK_TYPE_EXCL",
}

var LockType_value = map[string]int32{
	"LOCK_TYPE_INVALID": 0,
	"LOCK_TYPE_SHARED":  1,
	"LOCK_TYPE_WRITE":   2,
	"LOCK_TYPE_EXCL":    3,
}

func (x LockType) String() string {
	return proto.EnumName(LockType_name, int32(x))
}

func (LockType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{0}
}

// The available types of resources.
type ResourceType int32

const (
	ResourceType_RESOURCE_TYPE_INVALID ResourceType = 0
	// The file type represents a type
	// that holds arbitrary data.
	// Service implementors usually map this type
	// to files (local filesystem) or objects
	// (Amazon S3).
	ResourceType_RESOURCE_TYPE_FILE ResourceType = 1
	// The container type represents a type
	// that can contain another types.
	// Service implementors usually map this type
	// to folders (local filesystem) or buckets
	// (Amazon S3).
	ResourceType_RESOURCE_TYPE_CONTAINER ResourceType = 2
	// This represents a reference type which points
	// to another resource where client MAY be redirected.
	// Client SHOULD use the ResourceInfo.target
	// reference for a subsequent call.
	ResourceType_RESOURCE_TYPE_REFERENCE ResourceType = 3
	// This represents a symbolic link type if the underlying
	// storage system supports it.
	// Symlink target SHOULD NOT be interpreted by the clients.
	ResourceType_RESOURCE_TYPE_SYMLINK ResourceType = 4
	// Internal resource type for some specific resources inside
	// a storage implementation.
	// For example, this type could be used to represent
	// a device file on a Linux filesystem.
	// Another example could be to represent an ongoing upload,
	// where an hypothetically user interface could show a loading icon
	// on this type of resources until the upload operation is completed.
	// Internal resources SHOULD NOT be moved to a different storage
	// provider.
	ResourceType_RESOURCE_TYPE_INTERNAL ResourceType = 5
)

var ResourceType_name = map[int32]string{
	0: "RESOURCE_TYPE_INVALID",
	1: "RESOURCE_TYPE_FILE",
	2: "RESOURCE_TYPE_CONTAINER",
	3: "RESOURCE_TYPE_REFERENCE",
	4: "RESOURCE_TYPE_SYMLINK",
	5: "RESOURCE_TYPE_INTERNAL",
}

var ResourceType_value = map[string]int32{
	"RESOURCE_TYPE_INVALID":   0,
	"RESOURCE_TYPE_FILE":      1,
	"RESOURCE_TYPE_CONTAINER": 2,
	"RESOURCE_TYPE_REFERENCE": 3,
	"RESOURCE_TYPE_SYMLINK":   4,
	"RESOURCE_TYPE_INTERNAL":  5,
}

func (x ResourceType) String() string {
	return proto.EnumName(ResourceType_name, int32(x))
}

func (ResourceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{1}
}

// The type of checksum to use.
type ResourceChecksumType int32

const (
	ResourceChecksumType_RESOURCE_CHECKSUM_TYPE_INVALID ResourceChecksumType = 0
	// unset means no checksum is set.
	ResourceChecksumType_RESOURCE_CHECKSUM_TYPE_UNSET ResourceChecksumType = 1
	// Use Adler32 checksum.
	ResourceChecksumType_RESOURCE_CHECKSUM_TYPE_ADLER32 ResourceChecksumType = 2
	// Use MD5 checksum.
	ResourceChecksumType_RESOURCE_CHECKSUM_TYPE_MD5 ResourceChecksumType = 3
	// Use SHA-1 checksum.
	ResourceChecksumType_RESOURCE_CHECKSUM_TYPE_SHA1 ResourceChecksumType = 4
)

var ResourceChecksumType_name = map[int32]string{
	0: "RESOURCE_CHECKSUM_TYPE_INVALID",
	1: "RESOURCE_CHECKSUM_TYPE_UNSET",
	2: "RESOURCE_CHECKSUM_TYPE_ADLER32",
	3: "RESOURCE_CHECKSUM_TYPE_MD5",
	4: "RESOURCE_CHECKSUM_TYPE_SHA1",
}

var ResourceChecksumType_value = map[string]int32{
	"RESOURCE_CHECKSUM_TYPE_INVALID": 0,
	"RESOURCE_CHECKSUM_TYPE_UNSET":   1,
	"RESOURCE_CHECKSUM_TYPE_ADLER32": 2,
	"RESOURCE_CHECKSUM_TYPE_MD5":     3,
	"RESOURCE_CHECKSUM_TYPE_SHA1":    4,
}

func (x ResourceChecksumType) String() string {
	return proto.EnumName(ResourceChecksumType_name, int32(x))
}

func (ResourceChecksumType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{2}
}

// The type of the grantee.
type GranteeType int32

const (
	GranteeType_GRANTEE_TYPE_INVALID GranteeType = 0
	// This type represents an individual.
	GranteeType_GRANTEE_TYPE_USER GranteeType = 1
	// This type represents a group of individuals.
	GranteeType_GRANTEE_TYPE_GROUP GranteeType = 2
)

var GranteeType_name = map[int32]string{
	0: "GRANTEE_TYPE_INVALID",
	1: "GRANTEE_TYPE_USER",
	2: "GRANTEE_TYPE_GROUP",
}

var GranteeType_value = map[string]int32{
	"GRANTEE_TYPE_INVALID": 0,
	"GRANTEE_TYPE_USER":    1,
	"GRANTEE_TYPE_GROUP":   2,
}

func (x GranteeType) String() string {
	return proto.EnumName(GranteeType_name, int32(x))
}

func (GranteeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{3}
}

// Represents the information (metadata) about
// a storage resource organized in a hierarchical namespace (file, directory/container, reference, symlink, ...).
type ResourceInfo struct {
	// OPTIONAL.
	// Opaque information.
	Opaque *v1beta1.Opaque `protobuf:"bytes,1,opt,name=opaque,proto3" json:"opaque,omitempty"`
	// REQUIRED.
	// The type of the resource (container, file, ...)
	// See the enum ResourceType for all possible types.
	Type ResourceType `protobuf:"varint,2,opt,name=type,proto3,enum=cs3.storage.provider.v1beta1.ResourceType" json:"type,omitempty"`
	// REQUIRED.
	// Opaque unique identifier of the resource.
	Id *ResourceId `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	// REQUIRED.
	// The data checksum for the file resource.
	// For all other resources, the checksum is unset.
	Checksum *ResourceChecksum `protobuf:"bytes,4,opt,name=checksum,proto3" json:"checksum,omitempty"`
	// REQUIRED.
	// As decribed in https://tools.ietf.org/html/rfc7232#section-2.3
	// For file resources, the etag must change if data or metadata changes.
	// For container types, the etag must change if etag of any of the (indirectly) contained resources change.
	// For reference types, the etag must change if etag of the target changes and the target is on the same storage provider.
	// In all other cases the etag does not change.
	Etag string `protobuf:"bytes,5,opt,name=etag,proto3" json:"etag,omitempty"`
	// REQUIRED.
	// As described in [RFC 2015](https://tools.ietf.org/html/rfc2045#page-7)
	MimeType string `protobuf:"bytes,6,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	// REQUIRED.
	// Last modification time (mtime) of file or directory contents.
	// For reference types this is NOT the mtime of the target.
	Mtime *v1beta1.Timestamp `protobuf:"bytes,7,opt,name=mtime,proto3" json:"mtime,omitempty"`
	// REQUIRED.
	// The path for the resource:
	// MUST start with `/` when the reference had no resource_id, indicating an absolute path.
	// MUST start with `.` when the reference had a resource_id, indicating a relative path.
	Path string `protobuf:"bytes,8,opt,name=path,proto3" json:"path,omitempty"`
	// REQUIRED.
	// The set of permissions for the resource effective for the authenticated user.
	PermissionSet *ResourcePermissions `protobuf:"bytes,9,opt,name=permission_set,json=permissionSet,proto3" json:"permission_set,omitempty"`
	// REQUIRED.
	// The size of the resource in bytes (file size)
	// TODO(moscicki): This is undefined for container type.
	// Is the accounting recursive?, could it be set to 0 for directories if recursive not supported? use another field?
	// TODO(moscicki): This needs to be defined also for other types (such as a symlink to a directory or file)
	Size uint64 `protobuf:"varint,10,opt,name=size,proto3" json:"size,omitempty"`
	// REQUIRED.
	// Identifier of the owner of the resource.
	Owner *v1beta11.UserId `protobuf:"bytes,11,opt,name=owner,proto3" json:"owner,omitempty"`
	// OPTIONAL.
	// if ResourceType is either RESOURCE_TYPE_SYMLINK or RESOURCE_TYPE_REFERENCE
	// it MUST be specified.
	Target string `protobuf:"bytes,12,opt,name=target,proto3" json:"target,omitempty"`
	// OPTIONAL.
	// Additional metadata attached to the resource.
	// If ResourceType is RESOURCE_TYPE_REFERENCE it MUST
	// be specified.
	CanonicalMetadata *CanonicalMetadata `protobuf:"bytes,13,opt,name=canonical_metadata,json=canonicalMetadata,proto3" json:"canonical_metadata,omitempty"`
	// OPTIONAL.
	// Arbitrary metadata attached to a resource.
	ArbitraryMetadata *ArbitraryMetadata `protobuf:"bytes,14,opt,name=arbitrary_metadata,json=arbitraryMetadata,proto3" json:"arbitrary_metadata,omitempty"`
	// OPTIONAL.
	// Exclusive or write lock on this resource that will limit modification of the resource to holders of the lock.
	// Can be used by WOPI or other apps requiring write or exclusive locks.
	Lock *Lock `protobuf:"bytes,15,opt,name=lock,proto3" json:"lock,omitempty"`
	// OPTIONAL.
	// Advisory locks on this resource. Can be used for shared locks or other forms of collaborative locks.
	AdvisoryLocks []*Lock `protobuf:"bytes,16,rep,name=advisory_locks,json=advisoryLocks,proto3" json:"advisory_locks,omitempty"`
	// OPTIONAL.
	// Reference to the container of this resource. If path is relative it MUST be specified, regardless the
	// access restrictions to the resource: a subsequent Stat() on it MAY return access denied if appropriate.
	ParentId *ResourceId `protobuf:"bytes,17,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty"`
	// OPTIONAL
	// The name of the resource.
	Name string `protobuf:"bytes,18,opt,name=name,proto3" json:"name,omitempty"`
	// OPTIONAL.
	// StorageSpace where this resource is located.
	Space                *StorageSpace `protobuf:"bytes,19,opt,name=space,proto3" json:"space,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ResourceInfo) Reset()         { *m = ResourceInfo{} }
func (m *ResourceInfo) String() string { return proto.CompactTextString(m) }
func (*ResourceInfo) ProtoMessage()    {}
func (*ResourceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{0}
}

func (m *ResourceInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResourceInfo.Unmarshal(m, b)
}
func (m *ResourceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResourceInfo.Marshal(b, m, deterministic)
}
func (m *ResourceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceInfo.Merge(m, src)
}
func (m *ResourceInfo) XXX_Size() int {
	return xxx_messageInfo_ResourceInfo.Size(m)
}
func (m *ResourceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceInfo proto.InternalMessageInfo

func (m *ResourceInfo) GetOpaque() *v1beta1.Opaque {
	if m != nil {
		return m.Opaque
	}
	return nil
}

func (m *ResourceInfo) GetType() ResourceType {
	if m != nil {
		return m.Type
	}
	return ResourceType_RESOURCE_TYPE_INVALID
}

func (m *ResourceInfo) GetId() *ResourceId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ResourceInfo) GetChecksum() *ResourceChecksum {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func (m *ResourceInfo) GetEtag() string {
	if m != nil {
		return m.Etag
	}
	return ""
}

func (m *ResourceInfo) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *ResourceInfo) GetMtime() *v1beta1.Timestamp {
	if m != nil {
		return m.Mtime
	}
	return nil
}

func (m *ResourceInfo) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *ResourceInfo) GetPermissionSet() *ResourcePermissions {
	if m != nil {
		return m.PermissionSet
	}
	return nil
}

func (m *ResourceInfo) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *ResourceInfo) GetOwner() *v1beta11.UserId {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *ResourceInfo) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *ResourceInfo) GetCanonicalMetadata() *CanonicalMetadata {
	if m != nil {
		return m.CanonicalMetadata
	}
	return nil
}

func (m *ResourceInfo) GetArbitraryMetadata() *ArbitraryMetadata {
	if m != nil {
		return m.ArbitraryMetadata
	}
	return nil
}

func (m *ResourceInfo) GetLock() *Lock {
	if m != nil {
		return m.Lock
	}
	return nil
}

func (m *ResourceInfo) GetAdvisoryLocks() []*Lock {
	if m != nil {
		return m.AdvisoryLocks
	}
	return nil
}

func (m *ResourceInfo) GetParentId() *ResourceId {
	if m != nil {
		return m.ParentId
	}
	return nil
}

func (m *ResourceInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ResourceInfo) GetSpace() *StorageSpace {
	if m != nil {
		return m.Space
	}
	return nil
}

// CanonicalMetadata contains extra metadata
// attached to a resource. This message and the Opaque
// message differ in that Opaque allows service implementors
// to include any extra metadata in any format and most clients
// will ignore it. However, the CanonicalMetadata message
// contains well defined fileds that clients MUST understand if
// they are specified.
type CanonicalMetadata struct {
	// REQUIRED if resource type is RESOURCE_TYPE_REFERENCE.
	// The target reference the resource points to.
	Target               *Reference `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CanonicalMetadata) Reset()         { *m = CanonicalMetadata{} }
func (m *CanonicalMetadata) String() string { return proto.CompactTextString(m) }
func (*CanonicalMetadata) ProtoMessage()    {}
func (*CanonicalMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{1}
}

func (m *CanonicalMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CanonicalMetadata.Unmarshal(m, b)
}
func (m *CanonicalMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CanonicalMetadata.Marshal(b, m, deterministic)
}
func (m *CanonicalMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CanonicalMetadata.Merge(m, src)
}
func (m *CanonicalMetadata) XXX_Size() int {
	return xxx_messageInfo_CanonicalMetadata.Size(m)
}
func (m *CanonicalMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_CanonicalMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_CanonicalMetadata proto.InternalMessageInfo

func (m *CanonicalMetadata) GetTarget() *Reference {
	if m != nil {
		return m.Target
	}
	return nil
}

// Arbitrary metadata than can be set to the resource.
type ArbitraryMetadata struct {
	Metadata             map[string]string `protobuf:"bytes,1,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ArbitraryMetadata) Reset()         { *m = ArbitraryMetadata{} }
func (m *ArbitraryMetadata) String() string { return proto.CompactTextString(m) }
func (*ArbitraryMetadata) ProtoMessage()    {}
func (*ArbitraryMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{2}
}

func (m *ArbitraryMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ArbitraryMetadata.Unmarshal(m, b)
}
func (m *ArbitraryMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ArbitraryMetadata.Marshal(b, m, deterministic)
}
func (m *ArbitraryMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArbitraryMetadata.Merge(m, src)
}
func (m *ArbitraryMetadata) XXX_Size() int {
	return xxx_messageInfo_ArbitraryMetadata.Size(m)
}
func (m *ArbitraryMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ArbitraryMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ArbitraryMetadata proto.InternalMessageInfo

func (m *ArbitraryMetadata) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// The metadata associated with a lock on a resource.
// Provided that storage drivers are free to implement the storage
// of this metadata according to their constraints, a reference
// implementation is given here. The lock SHOULD be stored
// as an extended attribute on the referenced filesystem entry.
// Such extended attribute MUST NOT be exposed via the `Stat` and `SetArbitraryMetadata` APIs.
// Instead, the `ResourceInfo.Lock` attribute MUST be populated if a lock exists for the given reference.
type Lock struct {
	// OPTIONAL.
	// Opaque information.
	Opaque *v1beta1.Opaque `protobuf:"bytes,1,opt,name=opaque,proto3" json:"opaque,omitempty"`
	// REQUIRED.
	// The id of the lock, eg. the X-WOPI-Lock id or the WebDAV opaquelocktoken.
	LockId string `protobuf:"bytes,2,opt,name=lock_id,json=lockId,proto3" json:"lock_id,omitempty"`
	// REQUIRED.
	// The type of lock.
	Type LockType `protobuf:"varint,3,opt,name=type,proto3,enum=cs3.storage.provider.v1beta1.LockType" json:"type,omitempty"`
	// OPTIONAL.
	// The userid of a user, which represents either the lock holder, or the user that last created/modified the lock.
	// When non empty, `RefreshLock` and `Unlock` operations MUST check their request's content against it.
	User *v1beta11.UserId `protobuf:"bytes,4,opt,name=user,proto3" json:"user,omitempty"`
	// OPTIONAL.
	// An application name if the lock is held by an app.
	// When non empty, `RefreshLock` and `Unlock` operations MUST check their request's content against it.
	AppName string `protobuf:"bytes,5,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	// OPTIONAL.
	// The time when the lock will expire.
	Expiration           *v1beta1.Timestamp `protobuf:"bytes,6,opt,name=expiration,proto3" json:"expiration,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Lock) Reset()         { *m = Lock{} }
func (m *Lock) String() string { return proto.CompactTextString(m) }
func (*Lock) ProtoMessage()    {}
func (*Lock) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{3}
}

func (m *Lock) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Lock.Unmarshal(m, b)
}
func (m *Lock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Lock.Marshal(b, m, deterministic)
}
func (m *Lock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lock.Merge(m, src)
}
func (m *Lock) XXX_Size() int {
	return xxx_messageInfo_Lock.Size(m)
}
func (m *Lock) XXX_DiscardUnknown() {
	xxx_messageInfo_Lock.DiscardUnknown(m)
}

var xxx_messageInfo_Lock proto.InternalMessageInfo

func (m *Lock) GetOpaque() *v1beta1.Opaque {
	if m != nil {
		return m.Opaque
	}
	return nil
}

func (m *Lock) GetLockId() string {
	if m != nil {
		return m.LockId
	}
	return ""
}

func (m *Lock) GetType() LockType {
	if m != nil {
		return m.Type
	}
	return LockType_LOCK_TYPE_INVALID
}

func (m *Lock) GetUser() *v1beta11.UserId {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Lock) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

func (m *Lock) GetExpiration() *v1beta1.Timestamp {
	if m != nil {
		return m.Expiration
	}
	return nil
}

// The checksum to verify
// the integrity of a resource.
type ResourceChecksum struct {
	// REQUIRED.
	// The type of checksum to use.
	// If no checksum is provided,
	// type MUST be RESOURCE_CHECKSUM_TYPE_UNSET.
	Type ResourceChecksumType `protobuf:"varint,1,opt,name=type,proto3,enum=cs3.storage.provider.v1beta1.ResourceChecksumType" json:"type,omitempty"`
	// MUST be specified if type is not
	// RESOURCE_CHECKSUM_TYPE_UNSET or type is not
	// RESOURCE_CHECKSUM_TYPE_INVALID.
	// MUST be the hexadecimal representation of the cheksum.
	// The value is case-insensitive, so
	// "1E603A8", "1e603a8" or "1e603A8" are the same.
	Sum                  string   `protobuf:"bytes,2,opt,name=sum,proto3" json:"sum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceChecksum) Reset()         { *m = ResourceChecksum{} }
func (m *ResourceChecksum) String() string { return proto.CompactTextString(m) }
func (*ResourceChecksum) ProtoMessage()    {}
func (*ResourceChecksum) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{4}
}

func (m *ResourceChecksum) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResourceChecksum.Unmarshal(m, b)
}
func (m *ResourceChecksum) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResourceChecksum.Marshal(b, m, deterministic)
}
func (m *ResourceChecksum) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceChecksum.Merge(m, src)
}
func (m *ResourceChecksum) XXX_Size() int {
	return xxx_messageInfo_ResourceChecksum.Size(m)
}
func (m *ResourceChecksum) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceChecksum.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceChecksum proto.InternalMessageInfo

func (m *ResourceChecksum) GetType() ResourceChecksumType {
	if m != nil {
		return m.Type
	}
	return ResourceChecksumType_RESOURCE_CHECKSUM_TYPE_INVALID
}

func (m *ResourceChecksum) GetSum() string {
	if m != nil {
		return m.Sum
	}
	return ""
}

// When negotiating the user of checksum types
// between client and server, this structure
// defines the priority of the checksum.
// Priority 0 means highest priority.
type ResourceChecksumPriority struct {
	Type                 ResourceChecksumType `protobuf:"varint,1,opt,name=type,proto3,enum=cs3.storage.provider.v1beta1.ResourceChecksumType" json:"type,omitempty"`
	Priority             uint32               `protobuf:"varint,2,opt,name=priority,proto3" json:"priority,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ResourceChecksumPriority) Reset()         { *m = ResourceChecksumPriority{} }
func (m *ResourceChecksumPriority) String() string { return proto.CompactTextString(m) }
func (*ResourceChecksumPriority) ProtoMessage()    {}
func (*ResourceChecksumPriority) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{5}
}

func (m *ResourceChecksumPriority) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResourceChecksumPriority.Unmarshal(m, b)
}
func (m *ResourceChecksumPriority) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResourceChecksumPriority.Marshal(b, m, deterministic)
}
func (m *ResourceChecksumPriority) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceChecksumPriority.Merge(m, src)
}
func (m *ResourceChecksumPriority) XXX_Size() int {
	return xxx_messageInfo_ResourceChecksumPriority.Size(m)
}
func (m *ResourceChecksumPriority) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceChecksumPriority.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceChecksumPriority proto.InternalMessageInfo

func (m *ResourceChecksumPriority) GetType() ResourceChecksumType {
	if m != nil {
		return m.Type
	}
	return ResourceChecksumType_RESOURCE_CHECKSUM_TYPE_INVALID
}

func (m *ResourceChecksumPriority) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

// The mechanism to identify a resource in the CS3 namespace.
// It can represent path based, id based and combined references:
// The storage registry uses the storage_id to determine the responsible storage provider.
// When the storage_id is not available it will use the path.
// In a URL the different components can be represented in a string using the following layout:
// <storage_id>!<node_id>:<path>
type Reference struct {
	// OPTIONAL
	ResourceId *ResourceId `protobuf:"bytes,1,opt,name=resource_id,json=resourceId,proto3" json:"resource_id,omitempty"`
	// OPTIONAL.
	// When starting with `/` represents an absolute path. In this case the resource_id MUST be empty.
	// When starting with `.` represents a path relative to the resource_id. The resource_id MUST be given.
	// When path is empty the resource_id must be set. Used to look up the path for a resource_id.
	Path                 string   `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Reference) Reset()         { *m = Reference{} }
func (m *Reference) String() string { return proto.CompactTextString(m) }
func (*Reference) ProtoMessage()    {}
func (*Reference) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{6}
}

func (m *Reference) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Reference.Unmarshal(m, b)
}
func (m *Reference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Reference.Marshal(b, m, deterministic)
}
func (m *Reference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reference.Merge(m, src)
}
func (m *Reference) XXX_Size() int {
	return xxx_messageInfo_Reference.Size(m)
}
func (m *Reference) XXX_DiscardUnknown() {
	xxx_messageInfo_Reference.DiscardUnknown(m)
}

var xxx_messageInfo_Reference proto.InternalMessageInfo

func (m *Reference) GetResourceId() *ResourceId {
	if m != nil {
		return m.ResourceId
	}
	return nil
}

func (m *Reference) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// A resource id uniquely identifies a
// resource in the storage provider namespace.
// A ResourceId MUST be unique in the storage provider.
type ResourceId struct {
	// REQUIRED.
	// The logical id of a storage. Used by the storage
	// registry to determine the responsible storage provider.
	StorageId string `protobuf:"bytes,1,opt,name=storage_id,json=storageId,proto3" json:"storage_id,omitempty"`
	// REQUIRED.
	// The internal id used by service implementor to
	// uniquely identity the resource in the internal
	// implementation of the service.
	OpaqueId string `protobuf:"bytes,2,opt,name=opaque_id,json=opaqueId,proto3" json:"opaque_id,omitempty"`
	// OPTIONAL.
	// The internal id used by service implementor to
	// uniquely identify the storage space.
	// Used by the storageprovider to locate the correct storage space.
	SpaceId              string   `protobuf:"bytes,3,opt,name=space_id,json=spaceId,proto3" json:"space_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceId) Reset()         { *m = ResourceId{} }
func (m *ResourceId) String() string { return proto.CompactTextString(m) }
func (*ResourceId) ProtoMessage()    {}
func (*ResourceId) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{7}
}

func (m *ResourceId) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResourceId.Unmarshal(m, b)
}
func (m *ResourceId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResourceId.Marshal(b, m, deterministic)
}
func (m *ResourceId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceId.Merge(m, src)
}
func (m *ResourceId) XXX_Size() int {
	return xxx_messageInfo_ResourceId.Size(m)
}
func (m *ResourceId) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceId.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceId proto.InternalMessageInfo

func (m *ResourceId) GetStorageId() string {
	if m != nil {
		return m.StorageId
	}
	return ""
}

func (m *ResourceId) GetOpaqueId() string {
	if m != nil {
		return m.OpaqueId
	}
	return ""
}

func (m *ResourceId) GetSpaceId() string {
	if m != nil {
		return m.SpaceId
	}
	return ""
}

// The representation of permissions attached to a resource.
type ResourcePermissions struct {
	AddGrant             bool     `protobuf:"varint,1,opt,name=add_grant,json=addGrant,proto3" json:"add_grant,omitempty"`
	CreateContainer      bool     `protobuf:"varint,2,opt,name=create_container,json=createContainer,proto3" json:"create_container,omitempty"`
	Delete               bool     `protobuf:"varint,3,opt,name=delete,proto3" json:"delete,omitempty"`
	GetPath              bool     `protobuf:"varint,5,opt,name=get_path,json=getPath,proto3" json:"get_path,omitempty"`
	GetQuota             bool     `protobuf:"varint,6,opt,name=get_quota,json=getQuota,proto3" json:"get_quota,omitempty"`
	InitiateFileDownload bool     `protobuf:"varint,7,opt,name=initiate_file_download,json=initiateFileDownload,proto3" json:"initiate_file_download,omitempty"`
	InitiateFileUpload   bool     `protobuf:"varint,8,opt,name=initiate_file_upload,json=initiateFileUpload,proto3" json:"initiate_file_upload,omitempty"`
	ListGrants           bool     `protobuf:"varint,9,opt,name=list_grants,json=listGrants,proto3" json:"list_grants,omitempty"`
	ListContainer        bool     `protobuf:"varint,10,opt,name=list_container,json=listContainer,proto3" json:"list_container,omitempty"`
	ListFileVersions     bool     `protobuf:"varint,11,opt,name=list_file_versions,json=listFileVersions,proto3" json:"list_file_versions,omitempty"`
	ListRecycle          bool     `protobuf:"varint,12,opt,name=list_recycle,json=listRecycle,proto3" json:"list_recycle,omitempty"`
	Move                 bool     `protobuf:"varint,13,opt,name=move,proto3" json:"move,omitempty"`
	RemoveGrant          bool     `protobuf:"varint,14,opt,name=remove_grant,json=removeGrant,proto3" json:"remove_grant,omitempty"`
	PurgeRecycle         bool     `protobuf:"varint,15,opt,name=purge_recycle,json=purgeRecycle,proto3" json:"purge_recycle,omitempty"`
	RestoreFileVersion   bool     `protobuf:"varint,16,opt,name=restore_file_version,json=restoreFileVersion,proto3" json:"restore_file_version,omitempty"`
	RestoreRecycleItem   bool     `protobuf:"varint,17,opt,name=restore_recycle_item,json=restoreRecycleItem,proto3" json:"restore_recycle_item,omitempty"`
	Stat                 bool     `protobuf:"varint,18,opt,name=stat,proto3" json:"stat,omitempty"`
	UpdateGrant          bool     `protobuf:"varint,19,opt,name=update_grant,json=updateGrant,proto3" json:"update_grant,omitempty"`
	DenyGrant            bool     `protobuf:"varint,20,opt,name=deny_grant,json=denyGrant,proto3" json:"deny_grant,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourcePermissions) Reset()         { *m = ResourcePermissions{} }
func (m *ResourcePermissions) String() string { return proto.CompactTextString(m) }
func (*ResourcePermissions) ProtoMessage()    {}
func (*ResourcePermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{8}
}

func (m *ResourcePermissions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResourcePermissions.Unmarshal(m, b)
}
func (m *ResourcePermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResourcePermissions.Marshal(b, m, deterministic)
}
func (m *ResourcePermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourcePermissions.Merge(m, src)
}
func (m *ResourcePermissions) XXX_Size() int {
	return xxx_messageInfo_ResourcePermissions.Size(m)
}
func (m *ResourcePermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourcePermissions.DiscardUnknown(m)
}

var xxx_messageInfo_ResourcePermissions proto.InternalMessageInfo

func (m *ResourcePermissions) GetAddGrant() bool {
	if m != nil {
		return m.AddGrant
	}
	return false
}

func (m *ResourcePermissions) GetCreateContainer() bool {
	if m != nil {
		return m.CreateContainer
	}
	return false
}

func (m *ResourcePermissions) GetDelete() bool {
	if m != nil {
		return m.Delete
	}
	return false
}

func (m *ResourcePermissions) GetGetPath() bool {
	if m != nil {
		return m.GetPath
	}
	return false
}

func (m *ResourcePermissions) GetGetQuota() bool {
	if m != nil {
		return m.GetQuota
	}
	return false
}

func (m *ResourcePermissions) GetInitiateFileDownload() bool {
	if m != nil {
		return m.InitiateFileDownload
	}
	return false
}

func (m *ResourcePermissions) GetInitiateFileUpload() bool {
	if m != nil {
		return m.InitiateFileUpload
	}
	return false
}

func (m *ResourcePermissions) GetListGrants() bool {
	if m != nil {
		return m.ListGrants
	}
	return false
}

func (m *ResourcePermissions) GetListContainer() bool {
	if m != nil {
		return m.ListContainer
	}
	return false
}

func (m *ResourcePermissions) GetListFileVersions() bool {
	if m != nil {
		return m.ListFileVersions
	}
	return false
}

func (m *ResourcePermissions) GetListRecycle() bool {
	if m != nil {
		return m.ListRecycle
	}
	return false
}

func (m *ResourcePermissions) GetMove() bool {
	if m != nil {
		return m.Move
	}
	return false
}

func (m *ResourcePermissions) GetRemoveGrant() bool {
	if m != nil {
		return m.RemoveGrant
	}
	return false
}

func (m *ResourcePermissions) GetPurgeRecycle() bool {
	if m != nil {
		return m.PurgeRecycle
	}
	return false
}

func (m *ResourcePermissions) GetRestoreFileVersion() bool {
	if m != nil {
		return m.RestoreFileVersion
	}
	return false
}

func (m *ResourcePermissions) GetRestoreRecycleItem() bool {
	if m != nil {
		return m.RestoreRecycleItem
	}
	return false
}

func (m *ResourcePermissions) GetStat() bool {
	if m != nil {
		return m.Stat
	}
	return false
}

func (m *ResourcePermissions) GetUpdateGrant() bool {
	if m != nil {
		return m.UpdateGrant
	}
	return false
}

func (m *ResourcePermissions) GetDenyGrant() bool {
	if m != nil {
		return m.DenyGrant
	}
	return false
}

// A grant grants permissions
// to a resource to a grantee.
type Grant struct {
	// REQUIRED.
	// The grantee of the grant.
	Grantee *Grantee `protobuf:"bytes,1,opt,name=grantee,proto3" json:"grantee,omitempty"`
	// REQUIRED.
	// The permissions for the grant.
	Permissions *ResourcePermissions `protobuf:"bytes,2,opt,name=permissions,proto3" json:"permissions,omitempty"`
	// OPTIONAL
	// The Creator of the grant
	Creator              *v1beta11.UserId `protobuf:"bytes,3,opt,name=creator,proto3" json:"creator,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Grant) Reset()         { *m = Grant{} }
func (m *Grant) String() string { return proto.CompactTextString(m) }
func (*Grant) ProtoMessage()    {}
func (*Grant) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{9}
}

func (m *Grant) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Grant.Unmarshal(m, b)
}
func (m *Grant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Grant.Marshal(b, m, deterministic)
}
func (m *Grant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Grant.Merge(m, src)
}
func (m *Grant) XXX_Size() int {
	return xxx_messageInfo_Grant.Size(m)
}
func (m *Grant) XXX_DiscardUnknown() {
	xxx_messageInfo_Grant.DiscardUnknown(m)
}

var xxx_messageInfo_Grant proto.InternalMessageInfo

func (m *Grant) GetGrantee() *Grantee {
	if m != nil {
		return m.Grantee
	}
	return nil
}

func (m *Grant) GetPermissions() *ResourcePermissions {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *Grant) GetCreator() *v1beta11.UserId {
	if m != nil {
		return m.Creator
	}
	return nil
}

// A grantee is the receiver of a grant.
type Grantee struct {
	// REQUIRED.
	// The type of the grantee.
	Type GranteeType `protobuf:"varint,1,opt,name=type,proto3,enum=cs3.storage.provider.v1beta1.GranteeType" json:"type,omitempty"`
	// REQUIRED.
	// The unique id for the grantee.
	// One of the ids MUST be specified.
	//
	// Types that are valid to be assigned to Id:
	//	*Grantee_UserId
	//	*Grantee_GroupId
	Id isGrantee_Id `protobuf_oneof:"id"`
	// OPTIONAL.
	// Opaque information such as UID or GID.
	Opaque               *v1beta1.Opaque `protobuf:"bytes,5,opt,name=opaque,proto3" json:"opaque,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Grantee) Reset()         { *m = Grantee{} }
func (m *Grantee) String() string { return proto.CompactTextString(m) }
func (*Grantee) ProtoMessage()    {}
func (*Grantee) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{10}
}

func (m *Grantee) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Grantee.Unmarshal(m, b)
}
func (m *Grantee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Grantee.Marshal(b, m, deterministic)
}
func (m *Grantee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Grantee.Merge(m, src)
}
func (m *Grantee) XXX_Size() int {
	return xxx_messageInfo_Grantee.Size(m)
}
func (m *Grantee) XXX_DiscardUnknown() {
	xxx_messageInfo_Grantee.DiscardUnknown(m)
}

var xxx_messageInfo_Grantee proto.InternalMessageInfo

func (m *Grantee) GetType() GranteeType {
	if m != nil {
		return m.Type
	}
	return GranteeType_GRANTEE_TYPE_INVALID
}

type isGrantee_Id interface {
	isGrantee_Id()
}

type Grantee_UserId struct {
	UserId *v1beta11.UserId `protobuf:"bytes,3,opt,name=user_id,json=userId,proto3,oneof"`
}

type Grantee_GroupId struct {
	GroupId *v1beta12.GroupId `protobuf:"bytes,4,opt,name=group_id,json=groupId,proto3,oneof"`
}

func (*Grantee_UserId) isGrantee_Id() {}

func (*Grantee_GroupId) isGrantee_Id() {}

func (m *Grantee) GetId() isGrantee_Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Grantee) GetUserId() *v1beta11.UserId {
	if x, ok := m.GetId().(*Grantee_UserId); ok {
		return x.UserId
	}
	return nil
}

func (m *Grantee) GetGroupId() *v1beta12.GroupId {
	if x, ok := m.GetId().(*Grantee_GroupId); ok {
		return x.GroupId
	}
	return nil
}

func (m *Grantee) GetOpaque() *v1beta1.Opaque {
	if m != nil {
		return m.Opaque
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Grantee) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Grantee_UserId)(nil),
		(*Grantee_GroupId)(nil),
	}
}

// The information for a file version.
// TODO(labkode): make size and mtime OPTIONAL?
type FileVersion struct {
	// OPTIONAL.
	// Opaque information.
	Opaque *v1beta1.Opaque `protobuf:"bytes,1,opt,name=opaque,proto3" json:"opaque,omitempty"`
	// MUST the specified.
	// The key to identify the version.
	Key string `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	// REQUIRED.
	// The size in bytes of the file version.
	Size uint64 `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	// REQUIRED.
	// The Unix Epoch timestamp in seconds.
	Mtime uint64 `protobuf:"varint,5,opt,name=mtime,proto3" json:"mtime,omitempty"`
	// REQUIRED.
	// As decribed in https://tools.ietf.org/html/rfc7232#section-2.3
	// For a file version, the etag does not change because a version is immutable.
	Etag                 string   `protobuf:"bytes,6,opt,name=etag,proto3" json:"etag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileVersion) Reset()         { *m = FileVersion{} }
func (m *FileVersion) String() string { return proto.CompactTextString(m) }
func (*FileVersion) ProtoMessage()    {}
func (*FileVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{11}
}

func (m *FileVersion) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileVersion.Unmarshal(m, b)
}
func (m *FileVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileVersion.Marshal(b, m, deterministic)
}
func (m *FileVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileVersion.Merge(m, src)
}
func (m *FileVersion) XXX_Size() int {
	return xxx_messageInfo_FileVersion.Size(m)
}
func (m *FileVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_FileVersion.DiscardUnknown(m)
}

var xxx_messageInfo_FileVersion proto.InternalMessageInfo

func (m *FileVersion) GetOpaque() *v1beta1.Opaque {
	if m != nil {
		return m.Opaque
	}
	return nil
}

func (m *FileVersion) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *FileVersion) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *FileVersion) GetMtime() uint64 {
	if m != nil {
		return m.Mtime
	}
	return 0
}

func (m *FileVersion) GetEtag() string {
	if m != nil {
		return m.Etag
	}
	return ""
}

// A recycle item represents the information
// of a deleted resource.
type RecycleItem struct {
	// OPTIONAL.
	// Opaque information.
	Opaque *v1beta1.Opaque `protobuf:"bytes,1,opt,name=opaque,proto3" json:"opaque,omitempty"`
	// REQUIRED.
	// The type of the resource.
	Type ResourceType `protobuf:"varint,2,opt,name=type,proto3,enum=cs3.storage.provider.v1beta1.ResourceType" json:"type,omitempty"`
	// REQUIRED.
	// The key to identify the deleted resource.
	Key string `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	// REQUIRED.
	// The original reference of the deleted resource.
	Ref *Reference `protobuf:"bytes,4,opt,name=ref,proto3" json:"ref,omitempty"`
	// OPTIONAL.
	// The size of the deleted resource.
	Size uint64 `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
	// REQUIRED.
	// The deletion time of the resource
	// in Unix Epoch timestamp in seconds.
	DeletionTime         *v1beta1.Timestamp `protobuf:"bytes,6,opt,name=deletion_time,json=deletionTime,proto3" json:"deletion_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *RecycleItem) Reset()         { *m = RecycleItem{} }
func (m *RecycleItem) String() string { return proto.CompactTextString(m) }
func (*RecycleItem) ProtoMessage()    {}
func (*RecycleItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{12}
}

func (m *RecycleItem) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RecycleItem.Unmarshal(m, b)
}
func (m *RecycleItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RecycleItem.Marshal(b, m, deterministic)
}
func (m *RecycleItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecycleItem.Merge(m, src)
}
func (m *RecycleItem) XXX_Size() int {
	return xxx_messageInfo_RecycleItem.Size(m)
}
func (m *RecycleItem) XXX_DiscardUnknown() {
	xxx_messageInfo_RecycleItem.DiscardUnknown(m)
}

var xxx_messageInfo_RecycleItem proto.InternalMessageInfo

func (m *RecycleItem) GetOpaque() *v1beta1.Opaque {
	if m != nil {
		return m.Opaque
	}
	return nil
}

func (m *RecycleItem) GetType() ResourceType {
	if m != nil {
		return m.Type
	}
	return ResourceType_RESOURCE_TYPE_INVALID
}

func (m *RecycleItem) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *RecycleItem) GetRef() *Reference {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *RecycleItem) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *RecycleItem) GetDeletionTime() *v1beta1.Timestamp {
	if m != nil {
		return m.DeletionTime
	}
	return nil
}

// A file upload protocol object stores information about
// uploading resources using a specific protocol.
type FileUploadProtocol struct {
	// OPTIONAL.
	// Opaque information.
	Opaque *v1beta1.Opaque `protobuf:"bytes,1,opt,name=opaque,proto3" json:"opaque,omitempty"`
	// REQUIRED.
	// The protocol to be followed.
	Protocol string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// REQUIRED.
	// The endpoint where to upload the data.
	// The value MUST be a Uniform Resource Identifier (URI)
	// as specified in RFC 3986.
	UploadEndpoint string `protobuf:"bytes,3,opt,name=upload_endpoint,json=uploadEndpoint,proto3" json:"upload_endpoint,omitempty"`
	// REQUIRED.
	// List of available checksums
	// the client can use when sending
	// the file.
	AvailableChecksums []*ResourceChecksumPriority `protobuf:"bytes,4,rep,name=available_checksums,json=availableChecksums,proto3" json:"available_checksums,omitempty"`
	// REQUIRED.
	// Tells to the gateway if the client should be exposed directly to the upload_endpoint.
	Expose               bool     `protobuf:"varint,5,opt,name=expose,proto3" json:"expose,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileUploadProtocol) Reset()         { *m = FileUploadProtocol{} }
func (m *FileUploadProtocol) String() string { return proto.CompactTextString(m) }
func (*FileUploadProtocol) ProtoMessage()    {}
func (*FileUploadProtocol) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{13}
}

func (m *FileUploadProtocol) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileUploadProtocol.Unmarshal(m, b)
}
func (m *FileUploadProtocol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileUploadProtocol.Marshal(b, m, deterministic)
}
func (m *FileUploadProtocol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileUploadProtocol.Merge(m, src)
}
func (m *FileUploadProtocol) XXX_Size() int {
	return xxx_messageInfo_FileUploadProtocol.Size(m)
}
func (m *FileUploadProtocol) XXX_DiscardUnknown() {
	xxx_messageInfo_FileUploadProtocol.DiscardUnknown(m)
}

var xxx_messageInfo_FileUploadProtocol proto.InternalMessageInfo

func (m *FileUploadProtocol) GetOpaque() *v1beta1.Opaque {
	if m != nil {
		return m.Opaque
	}
	return nil
}

func (m *FileUploadProtocol) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *FileUploadProtocol) GetUploadEndpoint() string {
	if m != nil {
		return m.UploadEndpoint
	}
	return ""
}

func (m *FileUploadProtocol) GetAvailableChecksums() []*ResourceChecksumPriority {
	if m != nil {
		return m.AvailableChecksums
	}
	return nil
}

func (m *FileUploadProtocol) GetExpose() bool {
	if m != nil {
		return m.Expose
	}
	return false
}

// A file download protocol object stores information about
// downloading resources using a specific protocol.
type FileDownloadProtocol struct {
	// OPTIONAL.
	// Opaque information.
	Opaque *v1beta1.Opaque `protobuf:"bytes,1,opt,name=opaque,proto3" json:"opaque,omitempty"`
	// REQUIRED.
	// The protocol to be followed.
	Protocol string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// REQUIRED.
	// The endpoint where to download the data.
	// The value MUST be a Uniform Resource Identifier (URI)
	// as specified in RFC 3986.
	DownloadEndpoint string `protobuf:"bytes,3,opt,name=download_endpoint,json=downloadEndpoint,proto3" json:"download_endpoint,omitempty"`
	// REQUIRED.
	// Tells to the gateway if the client should be exposed directly to the download_endpoint.
	Expose               bool     `protobuf:"varint,4,opt,name=expose,proto3" json:"expose,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileDownloadProtocol) Reset()         { *m = FileDownloadProtocol{} }
func (m *FileDownloadProtocol) String() string { return proto.CompactTextString(m) }
func (*FileDownloadProtocol) ProtoMessage()    {}
func (*FileDownloadProtocol) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{14}
}

func (m *FileDownloadProtocol) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileDownloadProtocol.Unmarshal(m, b)
}
func (m *FileDownloadProtocol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileDownloadProtocol.Marshal(b, m, deterministic)
}
func (m *FileDownloadProtocol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileDownloadProtocol.Merge(m, src)
}
func (m *FileDownloadProtocol) XXX_Size() int {
	return xxx_messageInfo_FileDownloadProtocol.Size(m)
}
func (m *FileDownloadProtocol) XXX_DiscardUnknown() {
	xxx_messageInfo_FileDownloadProtocol.DiscardUnknown(m)
}

var xxx_messageInfo_FileDownloadProtocol proto.InternalMessageInfo

func (m *FileDownloadProtocol) GetOpaque() *v1beta1.Opaque {
	if m != nil {
		return m.Opaque
	}
	return nil
}

func (m *FileDownloadProtocol) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *FileDownloadProtocol) GetDownloadEndpoint() string {
	if m != nil {
		return m.DownloadEndpoint
	}
	return ""
}

func (m *FileDownloadProtocol) GetExpose() bool {
	if m != nil {
		return m.Expose
	}
	return false
}

// Represents a storage space which could be a 'home', 'share' etc...
type StorageSpace struct {
	// OPTIONAL.
	// Opaque information.
	Opaque *v1beta1.Opaque `protobuf:"bytes,1,opt,name=opaque,proto3" json:"opaque,omitempty"`
	// REQUIRED.
	Id *StorageSpaceId `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// OPTIONAL.
	Owner *v1beta11.User `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	// OPTIONAL.
	// The root resource id of the storage space.
	Root *ResourceId `protobuf:"bytes,4,opt,name=root,proto3" json:"root,omitempty"`
	// OPTIONAL.
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	// OPTIONAL.
	Quota *Quota `protobuf:"bytes,6,opt,name=quota,proto3" json:"quota,omitempty"`
	// OPTIONAL.
	// Could be 'home', 'share', 'project', 'space'...
	SpaceType string `protobuf:"bytes,7,opt,name=space_type,json=spaceType,proto3" json:"space_type,omitempty"`
	// OPTIONAL.
	// Last modification time (mtime) of the root resource of this storage space.
	Mtime *v1beta1.Timestamp `protobuf:"bytes,8,opt,name=mtime,proto3" json:"mtime,omitempty"`
	// OPTIONAL.
	// Resource info for the storage space root.
	RootInfo             *ResourceInfo `protobuf:"bytes,9,opt,name=root_info,json=rootInfo,proto3" json:"root_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *StorageSpace) Reset()         { *m = StorageSpace{} }
func (m *StorageSpace) String() string { return proto.CompactTextString(m) }
func (*StorageSpace) ProtoMessage()    {}
func (*StorageSpace) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{15}
}

func (m *StorageSpace) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageSpace.Unmarshal(m, b)
}
func (m *StorageSpace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageSpace.Marshal(b, m, deterministic)
}
func (m *StorageSpace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageSpace.Merge(m, src)
}
func (m *StorageSpace) XXX_Size() int {
	return xxx_messageInfo_StorageSpace.Size(m)
}
func (m *StorageSpace) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageSpace.DiscardUnknown(m)
}

var xxx_messageInfo_StorageSpace proto.InternalMessageInfo

func (m *StorageSpace) GetOpaque() *v1beta1.Opaque {
	if m != nil {
		return m.Opaque
	}
	return nil
}

func (m *StorageSpace) GetId() *StorageSpaceId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *StorageSpace) GetOwner() *v1beta11.User {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *StorageSpace) GetRoot() *ResourceId {
	if m != nil {
		return m.Root
	}
	return nil
}

func (m *StorageSpace) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StorageSpace) GetQuota() *Quota {
	if m != nil {
		return m.Quota
	}
	return nil
}

func (m *StorageSpace) GetSpaceType() string {
	if m != nil {
		return m.SpaceType
	}
	return ""
}

func (m *StorageSpace) GetMtime() *v1beta1.Timestamp {
	if m != nil {
		return m.Mtime
	}
	return nil
}

func (m *StorageSpace) GetRootInfo() *ResourceInfo {
	if m != nil {
		return m.RootInfo
	}
	return nil
}

// The id of a storage space.
type StorageSpaceId struct {
	// REQUIRED.
	// The internal storage space id.
	OpaqueId             string   `protobuf:"bytes,1,opt,name=opaque_id,json=opaqueId,proto3" json:"opaque_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StorageSpaceId) Reset()         { *m = StorageSpaceId{} }
func (m *StorageSpaceId) String() string { return proto.CompactTextString(m) }
func (*StorageSpaceId) ProtoMessage()    {}
func (*StorageSpaceId) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{16}
}

func (m *StorageSpaceId) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageSpaceId.Unmarshal(m, b)
}
func (m *StorageSpaceId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageSpaceId.Marshal(b, m, deterministic)
}
func (m *StorageSpaceId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageSpaceId.Merge(m, src)
}
func (m *StorageSpaceId) XXX_Size() int {
	return xxx_messageInfo_StorageSpaceId.Size(m)
}
func (m *StorageSpaceId) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageSpaceId.DiscardUnknown(m)
}

var xxx_messageInfo_StorageSpaceId proto.InternalMessageInfo

func (m *StorageSpaceId) GetOpaqueId() string {
	if m != nil {
		return m.OpaqueId
	}
	return ""
}

// Represents a quota for a storage space.
type Quota struct {
	// OPTIONAL.
	// Opaque information.
	Opaque *v1beta1.Opaque `protobuf:"bytes,1,opt,name=opaque,proto3" json:"opaque,omitempty"`
	// OPTIONAL.
	// The bytes quota for the user.
	QuotaMaxBytes uint64 `protobuf:"varint,2,opt,name=quota_max_bytes,json=quotaMaxBytes,proto3" json:"quota_max_bytes,omitempty"`
	// OPTIONAL.
	// The files quota for the user.
	QuotaMaxFiles        uint64   `protobuf:"varint,3,opt,name=quota_max_files,json=quotaMaxFiles,proto3" json:"quota_max_files,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Quota) Reset()         { *m = Quota{} }
func (m *Quota) String() string { return proto.CompactTextString(m) }
func (*Quota) ProtoMessage()    {}
func (*Quota) Descriptor() ([]byte, []int) {
	return fileDescriptor_b91600c359c2e479, []int{17}
}

func (m *Quota) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Quota.Unmarshal(m, b)
}
func (m *Quota) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Quota.Marshal(b, m, deterministic)
}
func (m *Quota) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Quota.Merge(m, src)
}
func (m *Quota) XXX_Size() int {
	return xxx_messageInfo_Quota.Size(m)
}
func (m *Quota) XXX_DiscardUnknown() {
	xxx_messageInfo_Quota.DiscardUnknown(m)
}

var xxx_messageInfo_Quota proto.InternalMessageInfo

func (m *Quota) GetOpaque() *v1beta1.Opaque {
	if m != nil {
		return m.Opaque
	}
	return nil
}

func (m *Quota) GetQuotaMaxBytes() uint64 {
	if m != nil {
		return m.QuotaMaxBytes
	}
	return 0
}

func (m *Quota) GetQuotaMaxFiles() uint64 {
	if m != nil {
		return m.QuotaMaxFiles
	}
	return 0
}

func init() {
	proto.RegisterEnum("cs3.storage.provider.v1beta1.LockType", LockType_name, LockType_value)
	proto.RegisterEnum("cs3.storage.provider.v1beta1.ResourceType", ResourceType_name, ResourceType_value)
	proto.RegisterEnum("cs3.storage.provider.v1beta1.ResourceChecksumType", ResourceChecksumType_name, ResourceChecksumType_value)
	proto.RegisterEnum("cs3.storage.provider.v1beta1.GranteeType", GranteeType_name, GranteeType_value)
	proto.RegisterType((*ResourceInfo)(nil), "cs3.storage.provider.v1beta1.ResourceInfo")
	proto.RegisterType((*CanonicalMetadata)(nil), "cs3.storage.provider.v1beta1.CanonicalMetadata")
	proto.RegisterType((*ArbitraryMetadata)(nil), "cs3.storage.provider.v1beta1.ArbitraryMetadata")
	proto.RegisterMapType((map[string]string)(nil), "cs3.storage.provider.v1beta1.ArbitraryMetadata.MetadataEntry")
	proto.RegisterType((*Lock)(nil), "cs3.storage.provider.v1beta1.Lock")
	proto.RegisterType((*ResourceChecksum)(nil), "cs3.storage.provider.v1beta1.ResourceChecksum")
	proto.RegisterType((*ResourceChecksumPriority)(nil), "cs3.storage.provider.v1beta1.ResourceChecksumPriority")
	proto.RegisterType((*Reference)(nil), "cs3.storage.provider.v1beta1.Reference")
	proto.RegisterType((*ResourceId)(nil), "cs3.storage.provider.v1beta1.ResourceId")
	proto.RegisterType((*ResourcePermissions)(nil), "cs3.storage.provider.v1beta1.ResourcePermissions")
	proto.RegisterType((*Grant)(nil), "cs3.storage.provider.v1beta1.Grant")
	proto.RegisterType((*Grantee)(nil), "cs3.storage.provider.v1beta1.Grantee")
	proto.RegisterType((*FileVersion)(nil), "cs3.storage.provider.v1beta1.FileVersion")
	proto.RegisterType((*RecycleItem)(nil), "cs3.storage.provider.v1beta1.RecycleItem")
	proto.RegisterType((*FileUploadProtocol)(nil), "cs3.storage.provider.v1beta1.FileUploadProtocol")
	proto.RegisterType((*FileDownloadProtocol)(nil), "cs3.storage.provider.v1beta1.FileDownloadProtocol")
	proto.RegisterType((*StorageSpace)(nil), "cs3.storage.provider.v1beta1.StorageSpace")
	proto.RegisterType((*StorageSpaceId)(nil), "cs3.storage.provider.v1beta1.StorageSpaceId")
	proto.RegisterType((*Quota)(nil), "cs3.storage.provider.v1beta1.Quota")
}

func init() {
	proto.RegisterFile("cs3/storage/provider/v1beta1/resources.proto", fileDescriptor_b91600c359c2e479)
}

var fileDescriptor_b91600c359c2e479 = []byte{
	// 1963 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0x5f, 0x73, 0xdb, 0xc6,
	0x11, 0x0f, 0xf8, 0x47, 0x04, 0x57, 0x12, 0x05, 0x9d, 0x68, 0x07, 0x96, 0xed, 0x58, 0x41, 0x26,
	0x89, 0xac, 0xba, 0x54, 0x24, 0xd5, 0x69, 0xfe, 0x38, 0x4d, 0x24, 0x0a, 0x96, 0x59, 0xeb, 0x5f,
	0x8f, 0x92, 0x1b, 0x77, 0x3c, 0x45, 0x21, 0xe0, 0xc4, 0xa0, 0x26, 0x01, 0x04, 0x00, 0x15, 0xb3,
	0x0f, 0x9d, 0xe9, 0x63, 0x3b, 0xd3, 0x99, 0x7e, 0x82, 0x76, 0xa6, 0xd3, 0x27, 0xf7, 0xad, 0xdf,
	0xa0, 0x33, 0x7d, 0xea, 0x47, 0xe8, 0x4b, 0xbf, 0x4a, 0xe7, 0xf6, 0x0e, 0x04, 0x28, 0x59, 0x12,
	0xa5, 0x69, 0xa7, 0x6f, 0x87, 0xdd, 0xfd, 0xed, 0xee, 0xed, 0xed, 0xed, 0xee, 0x01, 0x1e, 0x38,
	0xf1, 0xda, 0x72, 0x9c, 0x04, 0x91, 0xdd, 0x61, 0xcb, 0x61, 0x14, 0x9c, 0x78, 0x2e, 0x8b, 0x96,
	0x4f, 0x56, 0x8e, 0x58, 0x62, 0xaf, 0x2c, 0x47, 0x2c, 0x0e, 0xfa, 0x91, 0xc3, 0xe2, 0x46, 0x18,
	0x05, 0x49, 0x40, 0xee, 0x38, 0xf1, 0x5a, 0x43, 0x4a, 0x37, 0x52, 0xe9, 0x86, 0x94, 0x9e, 0x5f,
	0xe2, 0xba, 0x3c, 0x97, 0xf9, 0x89, 0x97, 0x0c, 0x96, 0x3b, 0x51, 0xd0, 0x0f, 0xcf, 0xd3, 0x34,
	0x7f, 0x7f, 0x44, 0xb6, 0x1f, 0x9f, 0x6f, 0x74, 0xfe, 0x2e, 0x17, 0x4d, 0x06, 0x21, 0x8b, 0x87,
	0x22, 0xf8, 0x25, 0xd8, 0xc6, 0x9f, 0x54, 0x98, 0xa2, 0x12, 0xd2, 0xf2, 0x8f, 0x03, 0xb2, 0x02,
	0x13, 0x41, 0x68, 0x7f, 0xdb, 0x67, 0xba, 0xb2, 0xa0, 0x2c, 0x4e, 0xae, 0xde, 0x6a, 0x70, 0xaf,
	0x05, 0x44, 0x2a, 0x68, 0xec, 0xa1, 0x00, 0x95, 0x82, 0xe4, 0x47, 0x50, 0xe2, 0x7c, 0xbd, 0xb0,
	0xa0, 0x2c, 0xd6, 0x56, 0x97, 0x1a, 0x17, 0x6d, 0xb3, 0x91, 0x1a, 0x3b, 0x18, 0x84, 0x8c, 0x22,
	0x8e, 0x7c, 0x02, 0x05, 0xcf, 0xd5, 0x8b, 0x68, 0x6e, 0x71, 0x3c, 0x74, 0xcb, 0xa5, 0x05, 0xcf,
	0x25, 0x3f, 0x06, 0xd5, 0xf9, 0x86, 0x39, 0x2f, 0xe3, 0x7e, 0x4f, 0x2f, 0x21, 0xbe, 0x31, 0x1e,
	0xbe, 0x29, 0x51, 0x74, 0x88, 0x27, 0x04, 0x4a, 0x2c, 0xb1, 0x3b, 0x7a, 0x79, 0x41, 0x59, 0xac,
	0x52, 0x5c, 0x93, 0xdb, 0x50, 0xed, 0x79, 0x3d, 0x66, 0xe1, 0xf6, 0x26, 0x90, 0xa1, 0x72, 0x02,
	0x77, 0x9e, 0xac, 0x42, 0xb9, 0x97, 0x78, 0x3d, 0xa6, 0x57, 0xd0, 0xf2, 0x9d, 0x37, 0x04, 0xea,
	0xc0, 0xeb, 0xb1, 0x38, 0xb1, 0x7b, 0x21, 0x15, 0xa2, 0xdc, 0x48, 0x68, 0x27, 0xdf, 0xe8, 0xaa,
	0x30, 0xc2, 0xd7, 0xe4, 0x6b, 0xa8, 0x85, 0x2c, 0xea, 0x79, 0x71, 0xec, 0x05, 0xbe, 0x15, 0xb3,
	0x44, 0xaf, 0xa2, 0xc2, 0x95, 0xf1, 0xb6, 0xb2, 0x3f, 0xc4, 0xc6, 0x74, 0x3a, 0x53, 0xd4, 0x66,
	0x09, 0xb7, 0x16, 0x7b, 0xbf, 0x62, 0x3a, 0x2c, 0x28, 0x8b, 0x25, 0x8a, 0x6b, 0xf2, 0x43, 0x28,
	0x07, 0xdf, 0xf9, 0x2c, 0xd2, 0x27, 0xd1, 0xc8, 0xbb, 0x68, 0x24, 0x4d, 0xa5, 0x06, 0x4f, 0xa5,
	0xa1, 0x85, 0xc3, 0x98, 0x45, 0x2d, 0x97, 0x0a, 0x79, 0x72, 0x13, 0x26, 0x12, 0x3b, 0xea, 0xb0,
	0x44, 0x9f, 0x42, 0xe7, 0xe5, 0x17, 0xf9, 0x39, 0x10, 0xc7, 0xf6, 0x03, 0xdf, 0x73, 0xec, 0xae,
	0xd5, 0x63, 0x89, 0xed, 0xda, 0x89, 0xad, 0x4f, 0xa3, 0xf6, 0xe5, 0x8b, 0xb7, 0xd0, 0x4c, 0x71,
	0x3b, 0x12, 0x46, 0x67, 0x9d, 0xd3, 0x24, 0xae, 0xdf, 0x8e, 0x8e, 0xbc, 0x24, 0xb2, 0xa3, 0x41,
	0xa6, 0xbf, 0x36, 0x8e, 0xfe, 0xf5, 0x14, 0x97, 0xe9, 0xb7, 0x4f, 0x93, 0xc8, 0xc7, 0x50, 0xea,
	0x06, 0xce, 0x4b, 0x7d, 0x06, 0x35, 0x1a, 0x17, 0x6b, 0xdc, 0x0e, 0x9c, 0x97, 0x14, 0xe5, 0x49,
	0x0b, 0x6a, 0xb6, 0x7b, 0xe2, 0xc5, 0x41, 0x34, 0xb0, 0x38, 0x21, 0xd6, 0xb5, 0x85, 0xe2, 0x98,
	0x1a, 0xa6, 0x53, 0x24, 0xff, 0x8a, 0x89, 0x09, 0xd5, 0xd0, 0x8e, 0x98, 0x9f, 0x58, 0x9e, 0xab,
	0xcf, 0x5e, 0xf1, 0x1e, 0xa8, 0x02, 0xda, 0x72, 0xf9, 0x71, 0xfb, 0x76, 0x8f, 0xe9, 0x44, 0x24,
	0x17, 0x5f, 0x93, 0xaf, 0xa0, 0x1c, 0x87, 0xb6, 0xc3, 0xf4, 0x39, 0x54, 0x7b, 0xc9, 0xe5, 0x6c,
	0x0b, 0x46, 0x9b, 0x23, 0xa8, 0x00, 0x1a, 0x07, 0x30, 0x7b, 0xe6, 0x9c, 0xc8, 0x97, 0xc3, 0x64,
	0x10, 0x55, 0xe2, 0xc3, 0xcb, 0xdc, 0x3d, 0x66, 0x11, 0xf3, 0x1d, 0x96, 0x66, 0x8d, 0xf1, 0x57,
	0x05, 0x66, 0xcf, 0x1c, 0x0f, 0x79, 0x0e, 0xea, 0xf0, 0x84, 0x15, 0x8c, 0xe6, 0x17, 0x57, 0x3c,
	0xe1, 0x46, 0xba, 0x30, 0xfd, 0x24, 0x1a, 0xd0, 0xa1, 0xba, 0xf9, 0xcf, 0x61, 0x7a, 0x84, 0x45,
	0x34, 0x28, 0xbe, 0x64, 0x03, 0xf4, 0xbf, 0x4a, 0xf9, 0x92, 0xd4, 0xa1, 0x7c, 0x62, 0x77, 0xfb,
	0xa2, 0x90, 0x55, 0xa9, 0xf8, 0xf8, 0xac, 0xf0, 0x89, 0x62, 0xfc, 0xb1, 0x00, 0x25, 0x7e, 0x54,
	0xd7, 0xa9, 0x8e, 0x6f, 0x43, 0x85, 0xa7, 0x07, 0x3f, 0x5a, 0xa1, 0x77, 0x82, 0x7f, 0xb6, 0x5c,
	0xf2, 0x99, 0x2c, 0x9b, 0x45, 0x2c, 0x9b, 0x1f, 0x5c, 0x9e, 0x36, 0xb9, 0x92, 0xf9, 0x10, 0x4a,
	0xfc, 0xaa, 0xca, 0xa2, 0x37, 0xc6, 0x25, 0x46, 0x71, 0x72, 0x0b, 0x54, 0x3b, 0x0c, 0x2d, 0xcc,
	0x12, 0x51, 0xe7, 0x2a, 0x76, 0x18, 0xee, 0xf2, 0x44, 0x79, 0x04, 0xc0, 0x5e, 0x85, 0x5e, 0x64,
	0x27, 0x5e, 0xe0, 0x63, 0xad, 0xbb, 0xac, 0xa4, 0xe5, 0xe4, 0x8d, 0x2e, 0x68, 0xa7, 0x4b, 0x2b,
	0x79, 0x2c, 0xf7, 0xa7, 0xe0, 0xfe, 0x56, 0xaf, 0x56, 0x98, 0x73, 0x7b, 0xd5, 0xa0, 0xc8, 0xeb,
	0xbb, 0x08, 0x1e, 0x5f, 0x1a, 0xbf, 0x06, 0xfd, 0xb4, 0xfc, 0x7e, 0xe4, 0x05, 0x91, 0x97, 0x0c,
	0xfe, 0x6b, 0x56, 0xe7, 0x41, 0x0d, 0xa5, 0x4e, 0x34, 0x3d, 0x4d, 0x87, 0xdf, 0xc6, 0x2f, 0xa1,
	0x3a, 0xcc, 0x68, 0xd2, 0x82, 0xc9, 0xb4, 0xe7, 0xf2, 0x33, 0x56, 0xae, 0x78, 0x7d, 0x21, 0x1a,
	0xae, 0x87, 0xdd, 0xa1, 0x90, 0x75, 0x07, 0xc3, 0x01, 0xc8, 0xa4, 0xc9, 0x5d, 0x00, 0xa9, 0x34,
	0xb5, 0x55, 0xa5, 0x55, 0x49, 0x69, 0xb9, 0xbc, 0x5f, 0x89, 0xac, 0xcb, 0xb2, 0x4d, 0x15, 0x84,
	0x96, 0xcb, 0x0f, 0x1f, 0x6f, 0xb4, 0x25, 0x9b, 0x6d, 0x95, 0x56, 0xf0, 0xbb, 0xe5, 0x1a, 0xff,
	0x28, 0xc3, 0xdc, 0x1b, 0xfa, 0x09, 0xd7, 0x67, 0xbb, 0xae, 0xd5, 0x89, 0x6c, 0x5f, 0xdc, 0x74,
	0x95, 0xaa, 0xb6, 0xeb, 0x6e, 0xf1, 0x6f, 0x72, 0x1f, 0x34, 0x27, 0x62, 0x76, 0xc2, 0x2c, 0x27,
	0xf0, 0x13, 0xdb, 0xe3, 0x4d, 0xa5, 0x80, 0x32, 0x33, 0x82, 0xde, 0x4c, 0xc9, 0xbc, 0x77, 0xb8,
	0xac, 0xcb, 0x12, 0x91, 0xec, 0x2a, 0x95, 0x5f, 0xdc, 0xa5, 0x0e, 0x4b, 0x2c, 0xdc, 0x74, 0x19,
	0x39, 0x95, 0x0e, 0x4b, 0xf6, 0x79, 0x57, 0xbc, 0x0d, 0x55, 0xce, 0xfa, 0xb6, 0x1f, 0x24, 0x36,
	0xa6, 0xa3, 0x4a, 0xb9, 0xec, 0x4f, 0xf8, 0x37, 0xf9, 0x01, 0xdc, 0xf4, 0x7c, 0x2f, 0xf1, 0xb8,
	0xf1, 0x63, 0xaf, 0xcb, 0x2c, 0x37, 0xf8, 0xce, 0xef, 0x06, 0xb6, 0x8b, 0xbd, 0x58, 0xa5, 0xf5,
	0x94, 0xfb, 0xd8, 0xeb, 0xb2, 0x4d, 0xc9, 0x23, 0x1f, 0x41, 0x7d, 0x14, 0xd5, 0x0f, 0x11, 0xa3,
	0x22, 0x86, 0xe4, 0x31, 0x87, 0xc8, 0x21, 0xf7, 0x60, 0xb2, 0xeb, 0xc5, 0x89, 0x08, 0x40, 0x8c,
	0x7d, 0x59, 0xa5, 0xc0, 0x49, 0x18, 0x82, 0x98, 0xbc, 0x0f, 0x35, 0x14, 0xc8, 0x22, 0x00, 0x28,
	0x33, 0xcd, 0xa9, 0xd9, 0xfe, 0x1f, 0x00, 0x41, 0x31, 0xb4, 0x7a, 0xc2, 0x22, 0x8c, 0x2e, 0x76,
	0x60, 0x95, 0x6a, 0x9c, 0xc3, 0x6d, 0x3e, 0x93, 0x74, 0xf2, 0x2e, 0x4c, 0xa1, 0x74, 0xc4, 0x9c,
	0x81, 0xd3, 0x65, 0xd8, 0x6f, 0x55, 0x8a, 0x9e, 0x50, 0x41, 0xe2, 0x99, 0xd2, 0x0b, 0x4e, 0x18,
	0xb6, 0x59, 0x95, 0xe2, 0x9a, 0xc3, 0x22, 0xc6, 0x57, 0xf2, 0xbc, 0x6a, 0x02, 0x26, 0x68, 0xe2,
	0xc8, 0xde, 0x83, 0xe9, 0xb0, 0x1f, 0x75, 0xd8, 0x50, 0xf5, 0x0c, 0xca, 0x4c, 0x21, 0x31, 0xd5,
	0xfd, 0x11, 0xd4, 0x23, 0xc6, 0x73, 0x8a, 0x8d, 0xf8, 0xab, 0x6b, 0x22, 0x4c, 0x92, 0x97, 0xf3,
	0x38, 0x8f, 0x90, 0x8a, 0x2d, 0x2f, 0x61, 0x3d, 0x6c, 0x65, 0x19, 0x42, 0xea, 0x6f, 0x25, 0x0c,
	0x87, 0xad, 0x38, 0xb1, 0x13, 0x6c, 0x55, 0x2a, 0xc5, 0x35, 0xf7, 0xbf, 0x1f, 0xba, 0xfc, 0x70,
	0x84, 0xff, 0x73, 0xc2, 0x7f, 0x41, 0x13, 0xfe, 0xdf, 0x05, 0x70, 0x99, 0x3f, 0x90, 0x02, 0x75,
	0x14, 0xa8, 0x72, 0x0a, 0xb2, 0x8d, 0x7f, 0x29, 0x50, 0x16, 0x82, 0x5f, 0x42, 0x05, 0x65, 0x58,
	0x5a, 0xa8, 0xdf, 0xbf, 0xf8, 0x42, 0x6e, 0x09, 0x61, 0x9a, 0xa2, 0x48, 0x1b, 0x26, 0xb3, 0x59,
	0x2a, 0xc6, 0xbc, 0xbe, 0xd6, 0x44, 0x96, 0xd7, 0x42, 0x3e, 0x87, 0x0a, 0xde, 0x8c, 0x20, 0x92,
	0xd3, 0xee, 0x18, 0x85, 0x3b, 0x45, 0x18, 0xbf, 0x29, 0x40, 0x45, 0xba, 0x49, 0xbe, 0x18, 0x29,
	0x72, 0xf7, 0xc7, 0xda, 0x5b, 0xae, 0xb6, 0x3d, 0x82, 0x0a, 0x37, 0x65, 0x0d, 0xa7, 0xee, 0xcb,
	0xfd, 0x78, 0xf2, 0x16, 0x9d, 0xe8, 0xe3, 0x8a, 0x7c, 0x05, 0x2a, 0xbe, 0x4e, 0x38, 0x5c, 0xf4,
	0x9f, 0xf7, 0x46, 0xe1, 0xc8, 0xcd, 0x99, 0x0f, 0xfa, 0x21, 0x2a, 0xa8, 0x74, 0xc4, 0x32, 0xd7,
	0x45, 0xcb, 0x63, 0x76, 0xd1, 0x8d, 0x12, 0x7f, 0x23, 0x18, 0x7f, 0x50, 0x60, 0x32, 0x9f, 0x78,
	0xd7, 0x68, 0xc7, 0xb2, 0xed, 0x17, 0xb3, 0xb6, 0x9f, 0x4e, 0xc9, 0xa5, 0xdc, 0x94, 0x5c, 0x4f,
	0x67, 0xfb, 0x32, 0x12, 0xb3, 0xe9, 0x1d, 0x9f, 0x08, 0x13, 0xd9, 0x13, 0xc1, 0xf8, 0x4b, 0x01,
	0x26, 0xf3, 0x99, 0xfd, 0x7f, 0x78, 0x3f, 0x9d, 0xdd, 0xd2, 0xa7, 0x50, 0x8c, 0xd8, 0xb1, 0x3c,
	0x9d, 0xb1, 0x67, 0x33, 0x8e, 0x19, 0x46, 0xa3, 0x9c, 0x8b, 0xc6, 0x3a, 0x4c, 0x63, 0xc1, 0xe6,
	0xef, 0x13, 0x8c, 0xca, 0x38, 0xe3, 0xc1, 0x54, 0x0a, 0xe1, 0x24, 0xe3, 0xf7, 0x05, 0x20, 0x59,
	0x61, 0xdd, 0xe7, 0x6f, 0x4f, 0x27, 0xe8, 0x5e, 0x27, 0x5a, 0xd8, 0x98, 0x05, 0x3c, 0x6d, 0x71,
	0xe9, 0x37, 0xf9, 0x10, 0x66, 0x44, 0x4d, 0xb7, 0x98, 0xef, 0x86, 0x81, 0xe7, 0x27, 0x32, 0x2a,
	0x35, 0x41, 0x36, 0x25, 0x95, 0x74, 0x60, 0xce, 0x3e, 0xb1, 0xbd, 0xae, 0x7d, 0xd4, 0x65, 0x56,
	0xfa, 0x04, 0x8c, 0xf5, 0x12, 0xce, 0x9c, 0x1f, 0x5f, 0x6d, 0x68, 0x48, 0x47, 0x0f, 0x4a, 0x86,
	0x2a, 0x53, 0x56, 0xcc, 0x3b, 0x1f, 0x7b, 0x15, 0x06, 0x31, 0x93, 0xfd, 0x4d, 0x7e, 0x19, 0xaf,
	0x15, 0xa8, 0xe7, 0x9b, 0xd3, 0xff, 0x2a, 0x22, 0xdf, 0x83, 0xd9, 0xb4, 0x37, 0x9e, 0x8e, 0x89,
	0x96, 0x32, 0x86, 0x51, 0xc9, 0x9c, 0x2d, 0x8d, 0x38, 0xfb, 0xef, 0x22, 0x4c, 0xe5, 0x9f, 0x06,
	0xd7, 0x71, 0xf2, 0x11, 0x3e, 0xf2, 0x45, 0x1d, 0x7d, 0x30, 0xfe, 0x2b, 0x44, 0x3e, 0xf4, 0x1f,
	0xa6, 0xaf, 0x56, 0x51, 0xaf, 0xee, 0x5d, 0x52, 0xaf, 0xd2, 0x37, 0xeb, 0x23, 0x28, 0x45, 0x41,
	0x90, 0xc8, 0x8b, 0x30, 0xfe, 0x50, 0x86, 0xa8, 0xe1, 0x7b, 0xaa, 0x9c, 0x7b, 0x4f, 0x7d, 0x0a,
	0xe5, 0x6c, 0x24, 0x49, 0x2b, 0xdf, 0xb9, 0x2a, 0x71, 0x5a, 0xa1, 0x02, 0x81, 0xb3, 0x1b, 0xce,
	0x5f, 0x78, 0xd9, 0x2b, 0x72, 0x76, 0xe3, 0x94, 0xd1, 0xdf, 0x09, 0xea, 0xf8, 0xbf, 0x13, 0xb6,
	0xa0, 0xca, 0x3d, 0xb5, 0x3c, 0xff, 0x38, 0x90, 0x7f, 0x0d, 0xc6, 0x2c, 0x1f, 0x2d, 0xff, 0x38,
	0xa0, 0x2a, 0x07, 0xf3, 0x95, 0xf1, 0x7d, 0xa8, 0x8d, 0x46, 0x7d, 0x74, 0x94, 0x54, 0x46, 0x47,
	0x49, 0xe3, 0x77, 0x0a, 0x94, 0xc5, 0x24, 0x76, 0x8d, 0x4c, 0xf8, 0x00, 0x66, 0x30, 0x20, 0x56,
	0xcf, 0x7e, 0x65, 0x1d, 0x0d, 0x12, 0x26, 0xda, 0x6b, 0x89, 0x4e, 0x23, 0x79, 0xc7, 0x7e, 0xb5,
	0xc1, 0x89, 0xa3, 0x72, 0x7c, 0x12, 0x89, 0xf1, 0xf4, 0x73, 0x72, 0xfc, 0x02, 0xc5, 0x4b, 0xbf,
	0x00, 0x35, 0x7d, 0x1d, 0x91, 0x1b, 0x30, 0xbb, 0xbd, 0xd7, 0x7c, 0x6a, 0x1d, 0x3c, 0xdf, 0x37,
	0xad, 0xd6, 0xee, 0xb3, 0xf5, 0xed, 0xd6, 0xa6, 0xf6, 0x16, 0xa9, 0x83, 0x96, 0x91, 0xdb, 0x4f,
	0xd6, 0xa9, 0xb9, 0xa9, 0x29, 0x64, 0x0e, 0x66, 0x32, 0xea, 0x4f, 0x69, 0xeb, 0xc0, 0xd4, 0x0a,
	0x84, 0x40, 0x2d, 0x23, 0x9a, 0x5f, 0x37, 0xb7, 0xb5, 0xe2, 0xd2, 0xdf, 0x94, 0xec, 0x27, 0x19,
	0x9a, 0xb9, 0x05, 0x37, 0xa8, 0xd9, 0xde, 0x3b, 0xa4, 0x4d, 0xf3, 0xb4, 0xa9, 0x9b, 0x40, 0x46,
	0x59, 0x8f, 0x5b, 0xdb, 0xa6, 0xa6, 0x90, 0xdb, 0xf0, 0xf6, 0x28, 0xbd, 0xb9, 0xb7, 0x7b, 0xb0,
	0xde, 0xda, 0x35, 0xa9, 0x56, 0x38, 0xcb, 0xa4, 0xe6, 0x63, 0x93, 0x9a, 0xbb, 0x4d, 0x53, 0x2b,
	0x9e, 0x35, 0xd6, 0x7e, 0xbe, 0xb3, 0xdd, 0xda, 0x7d, 0xaa, 0x95, 0xc8, 0x3c, 0xdc, 0x3c, 0xed,
	0xc7, 0x81, 0x49, 0x77, 0xd7, 0xb7, 0xb5, 0xf2, 0xd2, 0xdf, 0x15, 0xa8, 0xbf, 0xe9, 0x7d, 0x43,
	0x0c, 0x78, 0x67, 0x08, 0x6a, 0x3e, 0x31, 0x9b, 0x4f, 0xdb, 0x87, 0x3b, 0xa7, 0x77, 0xb1, 0x00,
	0x77, 0xce, 0x91, 0x39, 0xdc, 0x6d, 0x9b, 0x07, 0x9a, 0x72, 0x81, 0x96, 0xf5, 0xcd, 0x6d, 0x93,
	0xae, 0xad, 0x6a, 0x05, 0xf2, 0x0e, 0xcc, 0x9f, 0x23, 0xb3, 0xb3, 0xf9, 0x50, 0x2b, 0x92, 0x7b,
	0x70, 0xfb, 0x1c, 0x7e, 0xfb, 0xc9, 0xfa, 0x8a, 0x56, 0x5a, 0x7a, 0x06, 0x93, 0xb9, 0xe9, 0x85,
	0xe8, 0x50, 0xdf, 0xa2, 0xeb, 0xbb, 0x07, 0xe6, 0x99, 0xa8, 0xdf, 0x80, 0xd9, 0x11, 0xce, 0x61,
	0xdb, 0xa4, 0x9a, 0xc2, 0x0f, 0x63, 0x84, 0xbc, 0x45, 0xf7, 0x0e, 0xf7, 0xb5, 0xc2, 0xc6, 0x6f,
	0x15, 0x58, 0x70, 0x82, 0xde, 0x85, 0x57, 0x65, 0xa3, 0x96, 0x46, 0x2f, 0xc6, 0xe2, 0xbc, 0xaf,
	0xfc, 0x6c, 0x26, 0x95, 0x91, 0x22, 0x7f, 0x2e, 0x14, 0x9b, 0xed, 0xfd, 0xd7, 0x85, 0x3b, 0xcd,
	0x78, 0x2d, 0xad, 0x5a, 0x8d, 0xfd, 0x54, 0xcf, 0xb3, 0x95, 0x0d, 0x2e, 0xf4, 0x4f, 0x64, 0xbf,
	0x90, 0xec, 0x17, 0x29, 0xfb, 0x85, 0x64, 0x1f, 0x4d, 0x60, 0xad, 0x5e, 0xfb, 0x4f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x10, 0x0b, 0x33, 0xab, 0x4c, 0x16, 0x00, 0x00,
}
